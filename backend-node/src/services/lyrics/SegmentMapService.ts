import { spawn } from 'node:child_process';
import { logger } from '../../utils/logger';
import { SegmentMap } from './types';

export class SegmentMapService {
    async getSegmentMap(trackId: string): Promise<SegmentMap | null> {
        try {
            const metadata = await this.fetchMetadata(trackId);
            if (!metadata) return null;

            // 1. Check if Art Track
            if (this.isArtTrack(metadata)) {
                logger.info({ trackId }, 'Identified as Art Track, no segment map needed');
                return null;
            }

            // 2. Check for Chapters
            const chapterOffset = this.getOffsetFromChapters(metadata);
            if (chapterOffset !== null) {
                return {
                    primaryVideoId: trackId,
                    counterpartVideoId: trackId, // We assume it maps to itself but with offset
                    primaryVideoStartTimeMilliseconds: chapterOffset,
                    counterpartVideoStartTimeMilliseconds: 0,
                    durationMilliseconds: metadata.duration * 1000
                };
            }

            // 3. Fallback / TODO: Search for counterpart
            logger.warn({ trackId }, 'Could not infer segment map for Music Video');
            return null;

        } catch (error) {
            logger.error({ error, trackId }, 'Failed to fetch segment map');
            return null;
        }
    }

    private isArtTrack(metadata: any): boolean {
        const description = metadata.description || '';
        return description.includes('Provided to YouTube by') || description.includes('Auto-generated by YouTube');
    }

    private getOffsetFromChapters(metadata: any): number | null {
        if (!metadata.chapters || !Array.isArray(metadata.chapters)) return null;

        // Heuristic: Look for "Intro"
        const intro = metadata.chapters.find((c: any) => c.title.toLowerCase().includes('intro'));
        if (intro) {
            // If intro exists, the song likely starts after it.
            // intro.end_time is in seconds.
            return intro.end_time * 1000;
        }

        return null;
    }

    private async fetchMetadata(trackId: string): Promise<any> {
        return new Promise((resolve, reject) => {
            const process = spawn('yt-dlp', ['--dump-json', `https://www.youtube.com/watch?v=${trackId}`]);

            let stdout = '';
            let stderr = '';

            process.stdout.on('data', (chunk) => stdout += chunk);
            process.stderr.on('data', (chunk) => stderr += chunk);

            process.on('close', (code) => {
                if (code !== 0) {
                    reject(new Error(`yt-dlp failed: ${stderr}`));
                    return;
                }
                try {
                    resolve(JSON.parse(stdout));
                } catch (e) {
                    reject(e);
                }
            });
        });
    }
}
