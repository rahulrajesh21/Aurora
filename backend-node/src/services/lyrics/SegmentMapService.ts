import { spawn } from 'node:child_process';
import { logger } from '../../utils/logger';
import { SegmentMap } from './types';
import { AppConfig } from '../../config/appConfig';
import fs from 'node:fs';
import path from 'node:path';

export class SegmentMapService {
    constructor(private readonly config: AppConfig) { }
    async getSegmentMap(trackId: string): Promise<SegmentMap | null> {
        try {
            const metadata = await this.fetchMetadata(trackId);
            if (!metadata) return null;

            // 1. Check if Art Track
            if (this.isArtTrack(metadata)) {
                logger.info({ trackId }, 'Identified as Art Track, no segment map needed');
                return null;
            }

            // 2. Check for Chapters
            const chapterOffset = this.getOffsetFromChapters(metadata);
            if (chapterOffset !== null) {
                return {
                    primaryVideoId: trackId,
                    counterpartVideoId: trackId, // We assume it maps to itself but with offset
                    primaryVideoStartTimeMilliseconds: chapterOffset,
                    counterpartVideoStartTimeMilliseconds: 0,
                    durationMilliseconds: metadata.duration * 1000
                };
            }

            // 3. Fallback / TODO: Search for counterpart
            logger.warn({ trackId }, 'Could not infer segment map for Music Video');
            return null;

        } catch (error) {
            logger.error({ error, trackId }, 'Failed to fetch segment map');
            return null;
        }
    }

    private isArtTrack(metadata: any): boolean {
        const description = metadata.description || '';
        return description.includes('Provided to YouTube by') || description.includes('Auto-generated by YouTube');
    }

    private getOffsetFromChapters(metadata: any): number | null {
        if (!metadata.chapters || !Array.isArray(metadata.chapters)) return null;

        // Heuristic: Look for "Intro"
        const intro = metadata.chapters.find((c: any) => c.title.toLowerCase().includes('intro'));
        if (intro) {
            // If intro exists, the song likely starts after it.
            // intro.end_time is in seconds.
            return intro.end_time * 1000;
        }

        return null;
    }

    private async fetchMetadata(trackId: string): Promise<any> {
        return new Promise((resolve, reject) => {
            const args = this.buildYtDlpArgs(trackId);
            args.push('--dump-json');

            const process = spawn('yt-dlp', args);

            let stdout = '';
            let stderr = '';

            process.stdout.on('data', (chunk) => stdout += chunk);
            process.stderr.on('data', (chunk) => stderr += chunk);

            process.on('close', (code) => {
                if (code !== 0) {
                    reject(new Error(`yt-dlp failed: ${stderr}`));
                    return;
                }
                try {
                    resolve(JSON.parse(stdout));
                } catch (e) {
                    reject(e);
                }
            });
        });
    }


    private buildYtDlpArgs(trackId: string): string[] {
        const args = [
            '--no-playlist',
            '--geo-bypass',
            '--force-ipv4',
        ];

        // Add user-agent
        const userAgent = this.config.youtube.ytdlp?.userAgent || 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36';
        args.push('--user-agent', userAgent);

        // Add cookies from environment variable or file
        const cookiesFromEnv = process.env.YTDLP_COOKIES;
        if (cookiesFromEnv) {
            // Write cookies from env to temporary file
            const tempCookiesPath = path.join(process.cwd(), '.cookies-temp.txt');
            try {
                fs.writeFileSync(tempCookiesPath, cookiesFromEnv, 'utf-8');
                args.push('--cookies', tempCookiesPath);
            } catch (error) {
                logger.error({ error }, 'Failed to write cookies from environment variable');
            }
        } else {
            // Fallback to cookies file path
            const cookiesPath = this.config.youtube.ytdlp?.cookiesPath;
            if (cookiesPath) {
                const resolvedCookiesPath = path.resolve(process.cwd(), cookiesPath);
                if (fs.existsSync(resolvedCookiesPath)) {
                    args.push('--cookies', resolvedCookiesPath);
                }
            }
        }

        // Add PO token if available
        if (this.config.youtube.ytdlp?.poToken) {
            args.push('--extractor-args', `youtube:po_token=${this.config.youtube.ytdlp.poToken}`);
        }

        // Add visitor data if available
        if (this.config.youtube.ytdlp?.visitorData) {
            args.push('--extractor-args', `youtube:visitor_data=${this.config.youtube.ytdlp.visitorData}`);
        }

        // Add POT provider args if enabled
        const potProviderConfig = this.config.youtube.ytdlp?.potProvider;
        if (potProviderConfig?.enabled) {
            const port = potProviderConfig.port || 4416;
            args.push('--extractor-args', `youtubepot-bgutilhttp:base_url=http://127.0.0.1:${port}`);
        }

        // Add other headers and options
        args.push(
            '--add-header', 'Accept-Language:en-US,en;q=0.9',
            // Use default client as recommended by yt-dlp for avoiding bot detection
            '--extractor-args', 'youtube:player_client=default',
            // Enable JavaScript runtime support (uses Node.js)
            '--js-runtimes', 'node',
            // Allow downloading remote JavaScript challenge solver from GitHub
            '--remote-components', 'ejs:github',
            '--no-check-certificates',
            `https://music.youtube.com/watch?v=${trackId}`
        );

        return args;
    }
}
